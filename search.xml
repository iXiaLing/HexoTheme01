<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sublime 笔记]]></title>
    <url>%2F2018%2F10%2Fsublime-1%2F</url>
    <content type="text"><![CDATA[什么是 sublimeSublime Text 是一个代码编辑器（Sublime Text 2 是收费软件，但可以无限期试用），也是 HTML 和散文先进的文本编辑器。Sublime Text 是由程序员 Jon Skinner 于 2008 年 1 月份所开发出来，它最初被设计为一个具有丰富扩展功能的 Vim本文地址：http://tigerliu.site/2017/06/sublime-1/ 1. 控制台安装 按Ctrl+`调出 console（注：安装有 QQ 输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至 QQ 拼音）粘贴以下代码到底部命令行并回车： 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启 Sublime Text 3 如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功 2. Package Control 安装插件 按下Ctrl+Shift+P调出命令 js 面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件 JS Format：一个JS代码格式化插件SublimeLinter：一个支持lint语法的插件，可以高亮linter认为有错误的代码行jQuery Package for sublime Text：如果你离不开jQuery的话，这个必备Emmet：Emmet 项目的前身是前端开发人员熟知的 Zen Coding（快速编写 HTML/CSS 代码的方案）AllAutocomplete：Sublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词SublimeREPL：这可能是对程序员最有用的插件。SublimeREPL 允许你在 Sublime Texxt 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）ColorPicker：通常，如果你想使用一个颜色选择器DocBlockr：如果你遵循的编码的风格很严格，这款插件能够使你的任务更容易SublimeCodeIntel：代码提示工具BracketHighlighter：成对匹配增强，并修改括号等的颜色ConvertToUTF8：UTF8转换FileDiffs：查找文档不同AutoFileName：自动提示路径插件HTML5：Sublime Text3支持HTML5Sass：Sublime Text3支持SassLess：Sublime Text3支持Less 3. 主题安装 常用的几款主题 Soda Theme SoDaReloaded Theme Flatland Theme Material Theme Boxy Theme 由于上面主题都已经被收录到Package Control 的数据库中，故最简单的方法是使用此方法进行安装。 使用Ctrl+Shift+P快捷键或者进入菜单：Preferences（首选项） - PackageControl（插件控制），调出命令输入框，输入Install Package 命令搜索 Theme - Soda 或者 Theme Flatland 等，回车确认安装即可。然后依然需要使用方法一的配置方式来激活新装的主题 下面为博主常用配置： SoDaReloaded +Flatland 备注：先分别安装 Flatland，SoDaReloaded 主题，然后进入 Preferences（首选项）-&gt;Set User(设置-用户) 123456789101112131415161718192021222324&#123; "color_scheme": "Packages/Theme - Flatland/Flatland Monokai.tmTheme", "draw_shadows": false, //忽略node_modules、.git、cvs、.svn等开头的文件夹 "folder_exclude_patterns": [ ".svn", ".git", ".hg", "CVS", "node_modules" ], "font_size": 14, "ignored_packages": [ "Vintage" ], "soda_classic_tabs": true, "soda_rect_scrollbars": true, "soda_tabs_autowidth": true, "theme": "SoDaReloaded Dark.sublime-theme", "update_check": false, "word_wrap": "auto"&#125; Material-Theme 备注：先安装 Material 主题，然后进入 Preferences（首选项）-&gt;Set User(设置-用户) 1234567891011121314151617181920212223242526272829303132&#123; "always_show_minimap_viewport": true, "bold_folder_labels": true, "color_scheme": "Packages/Material Theme/schemes/Material-Theme.tmTheme", "draw_shadows": false, "folder_exclude_patterns": [ ".svn", ".git", ".hg", "CVS", "node_modules" ], "font_options": [ "gray_antialias" ], "font_size": 13, "ignored_packages": [ "Vintage" ], "indent_guide_options": [ "draw_normal", "draw_active" ], "line_padding_bottom": 3, "line_padding_top": 3, "overlay_scroll_bars": "enabled", "theme": "Material-Theme.sublime-theme"&#125; 4. 自定义快捷键 进入 Preferences（首选项）-&gt;Key Bindings User(按键绑定-用户) 1234567891011121314151617181920[ &#123; keys: ['ctrl+shift+k'], command: 'find_under_expand' &#125;, &#123; keys: ['ctrl+k', 'ctrl+shift'], command: 'find_under_expand_skip' &#125;, // 删除当前行 &#123; keys: ['ctrl+d'], command: 'run_macro_file', args: &#123; file: 'res://Packages/Default/Delete Line.sublime-macro' &#125; &#125;, //大小写转换 &#123; keys: ['ctrl+shift+z'], command: 'upper_case' &#125;, &#123; keys: ['ctrl+shift+x'], command: 'lower_case' &#125;, // 复制选中行到行后 &#123; keys: ['ctrl+alt+down'], command: 'duplicate_line' &#125;, // 选词(按住-继续选择下个相同的字符串) &#123; keys: ['ctrl+g'], command: 'find_under_expand' &#125;, // gb一次选中所有的 &#123; keys: ['ctrl+g', 'ctrl+b'], command: 'find_all_under' &#125;, // 与上行互换 &#123; keys: ['alt+up'], command: 'swap_line_up' &#125;, // 与下行互换 &#123; keys: ['alt+down'], command: 'swap_line_down' &#125;, &#123; keys: ['alt+/', 'alt+/'], command: 'insert_best_completion' &#125;]; 5.常用快捷键 Ctrl+Shift+T可以打开之前关闭的tab页，这点同 chrome 是一样的 Ctrl+R定位函数； Ctrl+G定位到行； 有时我们需要对一片区域的所有行进行同时编辑，Ctrl+Shift+L可以将当前选中区域打散，然后进行同时编辑 有打散自然就有合并，Ctrl + J(mac 下 Command ＋ J)可以把当前选中区域合并为一行： 在Ctrl + P(Command+P)匹配到文件后，我们可以进行后续输入以跳转到更精确的位置 Ctrl + Enter(Mac~Command+Enter)在当前行下面新增一行然后跳至该行； Ctrl + Shift + Enter在当前行上面增加一行并跳至该行 Ctrl + ↑/↓移动当前显示区域 Ctrl + Shift + ↑/↓移动当前行 Ctrl + N在当前窗口创建一个新标签， Ctrl + W关闭当前标签， Ctrl + Shift + T恢复刚刚关闭的标签编辑代码时我们经常会开多个窗口，所以分屏很重要。 Windows 下：Alt + Shift + 2进行左右分屏， Alt + Shift + 8进行上下分屏， Alt + Shift + 5进行上下左右分屏（即分为四屏）Sublime text 删除插件步骤：“Ctrl+Shift+P”—“Remove Package”—“找到需要删除的插件，并点击即可删除”]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>IDE</tag>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 二三事]]></title>
    <url>%2F2018%2F10%2FGit-1%2F</url>
    <content type="text"><![CDATA[什么是Git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 本文地址：http://tigerliu.site/2017/06/Git-1/ 1. Git版本库 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库 通过命令 git init 把这个目录变成git可以管理的仓库，如下： 这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下： 把文件添加到版本库中。 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 2. Git常用命令git init 初始化git仓库 git add 添加到暂存区 git add . 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u 他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untrackedfile）。（git add –update的缩写） git add -A 是上面两个功能的合集（git add –all的缩写） git add xx文件名 单个文件添加到仓库 总结： · git add -A 提交所有变化 · git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) · git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 提交到仓库 1$ git commit -m '注释xxx' 查看是否还有文件未提交 1$ git status 查看某文件是否有改动 1$ git diff xxx文件名 查看下历史记录 1$ git log 查看日志单行显示 1$ git log –pretty=oneline 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 1$ git reset –-hard HEAD^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作 1$ git reset –-hard HEAD~100 可以通过如下命令即可获取到版本号1$ git reflog 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令git reset –hard 6fcfc89来恢复了 查看文件内容1$ cat xxx文件名 可以丢弃工作区的修改1$ git checkout -- file 删除文件命令1$ rm file 如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉 只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？ 可以使用如下命令 git checkout — b.txt，如下所示： 3. Git修改用户名以及提交邮箱 git 修改当前的project的用户名的命令为： 1$ git config user.name 你的目标用户名; git 修改当前的project提交邮箱的命令为： 1$ git config user.email 你的目标邮箱名; 如果你要修改当前全局的用户名和邮箱时，需要在上面的两条命令中添加一个参数，–global，代表的是全局。 命令分别为：12$ git config --global user.name 你的目标用户名；$ git config --global user.email 你的目标邮箱名; 当然，你还可以直接修改git的配置文件的方式来进行修改。 打开全局的.gitconfig文件的命令为：1$ vi ~/.gitconfig; 然后在文件中直接修改即可. 打开当前project 中的config文件，该文件在每个project中的.git目录下，直接进入该目录进行编辑即可。当然，如果没有进行过修改的话，默认打开时没有对应的用户名和密码的。只有进行过修改之后，才会在config中产生对应字段 4. Git本地仓库与Github远程仓库关联如果你已经在本地创建了一个Git仓库，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，那就需要用到SSH Key，github拿到了你的公钥就会知道内容是你推送的 SSH Key的配置： Windows下打开Git Bash，创建SSH Key，按提示输入密码，可以不填密码一路回车 1$ ssh-keygen -t rsa -C "注册邮箱" 然后用户主目录/.ssh/下有两个文件，id_rsa是私钥，id_rsa.pub是公钥 获取key，打开.ssh下的id_rsa.pub文件，里面的内容就是key的内容 1$ start ~/.ssh/id_rsa.pub 登录GitHub，打开”SSH Keys”页面，快捷地址：https://github.com/settings/ssh 测试ssh key是否成功，使用命令“ssh -T git@github.com”，如果出现You’ve successfullyauthenticated, but GitHub does not provide shellaccess。这就表示已成功连上github 从远程克隆一份到本地可以通过git clone 1$ git clone git@github.com:tiger6/xxx.git 本地库关联远程库，在本地仓库目录运行命令： 1$ git remote add origin git@github.com:tiger6/xxx.git 推送master分支的所有内容 1$ git push -u origin master 第一次使用加上了-u参数，是推送内容并关联分支。 推送成功后就可以看到远程和本地的内容一模一样，下次只要本地作了提交，就可以通过命令：1$ git push origin master 如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git1$ git push origin dev 把最新内容推送到Github 取回远程主机某个分支的更新(master主分支) 1$ git pull origin master 当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。 要查看远程库的信息 使用1$ git remote 要查看远程库的详细信息 使用1$ git remote –v 实战练习本地创建文本test.txt，运行: 123$ git add text.txt$ git commit -m "添加新文件"$ git push origin master 查看github是否同步 基本常用命令如下： mkdir： XX (创建一个空目录 XX指目录名) pwd： 显示当前目录的路径。 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git commit –m “XX” 提交文件 –m 后面的是注释。 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 ) cat XX 查看XX文件内容 git reflog 查看历史记录的版本号id git checkout — XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件 git remote add origin [https://github.com/tiger6/xxx 关联一个远程库 git remote rm origin 删除关联的远程库 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git clone [https://github.com/tiger6/xxx 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上 git branch 查看当前所有的分支 git checkout master 切换回master分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master Git会把master分支推送到远程库对应的远程分支上]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE使用中遇到的一些坑]]></title>
    <url>%2F2018%2F02%2Fvue2-k%2F</url>
    <content type="text"><![CDATA[前言前端开发对于vue的使用已经越来越多，我们在使用当中会遇到各种各样的问题，本篇主要归纳下在使用中遇到过的一些vue坑。 路由变化页面数据不刷新问题出现这种情况是因为依赖路由的params参数获取写在created生命周期里面，因为相同路由二次甚至多次加载的关系 没有达到监听，退出页面再进入另一个文章页面并不会运行created组件生命周期，导致文章数据还是第一次进入的数据。解决方法：watch监听路由是否变化1234567891011121314151617watch: &#123; // 方法1 '$route'(to, from) &#123; //监听路由是否变化 if(this.$route.params.articleId)&#123; // 判断条件1 判断传递值的变化 //获取文章数据 &#125; &#125; //方法2 '$route'(to, from) &#123; if(to.path == "/page") &#123; /// 判断条件2 监听路由名 监听你从什么路由跳转过来的 this.message = this.$route.query.msg &#125; &#125; &#125; 异步回调函数中使用this无法指向vue实例对象1234567891011121314//setTimeout/setInterval ajax Promise等等data()&#123; return&#123; ... &#125; &#125;,methods ()&#123; setTimeout( function() &#123; //其它几种情况相同 console.log(this);//此时this指向并不是vue实例 导致操作的一些ma'f &#125;,1000);&#125; 解决方案：变量赋值和箭头函数。（参考：var和let的区别：http://blog.csdn.net/nfer_zhuang/article/details/48781671）1234567891011//使用变量访问this实例let self=this; setTimeout( function()&#123; console.log(self); //使用self变量访问this实例&#125;,1000); //箭头函数访问this实例 因为箭头函数本身没有绑定this setTimeout(() =&gt; &#123; console.log(this);&#125;, 500); setInterval路由跳转继续运行并没有及时进行销毁比如一些弹幕，走马灯文字，这类需要定时调用的，路由跳转之后，因为组件已经销毁了，但是setInterval还没有销毁，还在继续后台调用，控制台会不断报错，如果运算量大的话，无法及时清除，会导致严重的页面卡顿.解决办法：在组件生命周期beforeDestroy停止setInterval12345//组件销毁前执行的钩子函数，跟其他生命周期钩子函数的用法相同。beforeDestroy()&#123; //我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么停止。 clearInterval(this.intervalId);&#125;, vue 滚动行为用法，进入路由需要滚动到浏览器底部、头部等等使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。注意：这个功能只在支持 history.pushState 的浏览器中可用。路由设置如下：（详情猛戳：https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html）1234567891011121314const router = newVueRouter(&#123; mode: 'history', scrollBehavior (to, from, savedPosition) &#123; if(savedPosition) &#123; //如果savedPosition存在，滚动条会自动跳到记录的值的地方 return savedPosition &#125;else&#123; return&#123; x: 0, y: 0&#125; //savedPosition也是一个记录x轴和y轴位置的对象 &#125; &#125;， routes: [...]&#125;) 实现vue路由拦截浏览器的需求，进行一系列操作，如草稿保存等等场景：为了防止用户失误点错关闭按钮等等，导致没有保存已输入的信息(关键信息)。 用法：12345678910//在路由组件中：...beforeRouteLeave (to, from, next) &#123; if(用户已经输入信息)&#123; //出现弹窗提醒保存草稿，或者自动后台为其保存 &#125;else&#123; next(true); //用户离开 &#125;&#125; 还有beforeEach、beforeRouteUpdate这些生命周期函数。 详情猛戳：https://router.vuejs.org/zh-cn/advanced/navigation-guards.html v-once 只渲染元素和组件一次，优化更新渲染性能v-once 这个指令相信大家用的很少，不过个人感觉还是挺实用的！只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。这个就不举例子了，直接猛戳这：v-once（https://cn.vuejs.org/v2/api/#v-once） vue本地代理配置 解决跨域问题,仅限于开发环境这个本地代理用来解决开发环境下的跨域问题，跨域可谓老生常谈的问题了，proxy 在 vue 中配置代理非常简单：1234567891011121314151617181920//比方说你要访问 http://192.168.1.xxx:8888/backEnd/paper这个接口//配置 config.js下面proxyTable对象proxyTable: &#123; '/backEnd':&#123; target:'http://192.168.3.200:8888', //目标接口域名有端口可以把端口也写上 //或者prot本地起服务端口与服务端统一 changeOrigin:true, &#125;&#125;,// 发送request请求axios.get('/backEnd/page') //按代理配置 匹配到/backEnd就代理到目标target地址.then((res) =&gt; &#123; console.log(res) // 数据完全拿得到 配置成功 this.newsList = res.data&#125;, (err) =&gt; &#123; console.log(err)&#125;) 本地开发没有任何问题，部署服务器就404啊这些问题由于前端路由缘故，单页面应用应该放到nginx或者apache、tomcat等web代理服务器中，千万不要直接访问index.html，同时要根据自己服务器的项目路径更改react或vue的路由地址。注意点： vue-router的 history 模式 服务nginx配置 具体详情可以猛戳：如何部署单页面项目到服务（https://segmentfault.com/a/1190000012675012） vue中传入事件$event在vue中，我们传入的事件一定是$event，但是获取时， e.currentTarget 和 e.target 获取的不一样的，区别在于 前者是当前的元素，即冒泡的最后一个绑定事件的元素，而后者是 最原始的元素。 关键： 后者可以实现事件代理 在v-for下的列表中，如何向方法传递参数？ 我们可以在一个list中绑定 v-for=”item,index in items”， 这样，我们就可以获取到相应的item和index（从0开始），另外，如果我们希望向list中的某个v-on:click = “handler” 传递参数，可以直接传递，比如： v-on:click=”handler(index)”， 这样就可以向methods下的handler传递参数了。 我们还可以传递$event直接给hanlder，然后通过e.currentTarget获取到这个元素。 结语其实很多问题都可以在API里找到，只是我们在使用的时候会遗忘，遇到问题可以先排查代码，然后再查询官网API，基本都会迎刃而解。本篇文章简单归纳了一些常见的问题，后续有其他问题会再次归纳总结！！！相关链接：https://segmentfault.com/a/1190000013008420]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Vue</tag>
        <tag>vue2.0</tag>
        <tag>前端框架</tag>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>vue入坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅的写CSS样式]]></title>
    <url>%2F2018%2F02%2Fcss%2F</url>
    <content type="text"><![CDATA[前言团队开发中，每个人的编码风格都不尽相同，有时候可能存在很大的差异，为了便于压缩组件对代码进行压缩以及书写样式的规范统一和美观，很有必要一起来讨论下如何优雅的写CSS。 css代码格式类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线这一点非常关键：根据xhtml规范，所有的标签属性和值都要使用小写形式，而我们知道xhtml更为标准，所以最好遵循之，这样，选择器必须小写就是十分必要的了。既然这样我们就不能使用驼峰式写法来写类名了，如class=”u-leftArrow”实际上就是不规范的了，最好写成class=”u-left_arrow”，也可以表达相同的意思。 不要使用 ID 选择器在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。 不要让嵌套选择器的深度超过 3 层！如果有必要用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。12345678910.btn &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); .icon &#123; margin-right: 10px; &#125;&#125; 不要在 CSS 和 JavaScript 中绑定相同的类避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。 我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：1&lt;button class="btn btn-primary js-request-to-book"&gt;Request to Book&lt;/button&gt; 单行写完一个选择器定义。优点：便于选择器的寻找和阅读，也便于插入新的选择器和编辑，便于模块等的识别。更重要的是可以去除多余空格，使代码紧凑减少换行。试想，如果每一行只有一个属性名和属性值，那么对于一个大项目而言，就很难做到选择器的寻找和阅读了，而使用一行写完一个选择器，那么就有可能缩短为1/6到1/10，这还是非常客观的。 最后一个值也要一分号结尾实际上，在大括号结束前的值可以省略分号，但是这样做会对修改、添加和维护工作带来不必要的失误和麻烦。比如，在最后添加一个属性，如果之前没有在末尾添加分号，那么你就要在新添加的属性前添加分号，否则就会出错，比如在我的一篇博文为解决中文字体显示为方框添加JSON数据时就出现过此类问题。 省略值为0的单位优点：可以节省不必要的字节同时也为了方便阅读，我们将0px、0em、0%等都缩写为0.如下所示：1.m-box&#123;margin:0 10px; backgrond-position:50% 0;&#125; 使用16进制表示颜色值，其中的字母使用大写形式，并尽量缩写除非在你需要透明度而使用rgba，否则都是用#FFFFFF这样的写法，并尽量缩写，如#FFF。使用大写形式，是因为这样更加具有易读性，且有利于压缩，而缩写为了减少不必要的字节。 PC端使用16进制表示颜色,IE8及以下不兼容,需要注意!!! 根据属性的重要性顺序书写只遵循横向顺序即可，即先书写定位布局类属性，在书写盒模型等自身属性，最后书写文本类及修饰类属性。 另外，如果属性间存在关联性，则不要隔开写，如下所示1.m-box&#123;position:relative;height:20px;line-height:20px; padding:5px;color:#000;&#125; 其中的height和line-height具有关联性，我们尽量不要分开写。 私有在前，标准在后先写带有浏览器私有标志的属性，后写W3C标准的属性。因为私有的属性，说明浏览器自身还没有规范化，标准属性是用不了的。若某一天该浏览器的属性规范化了，那么说明标准属性可以使用了，而如果我们先写W3C标准属性，最后写私有属性，就有可能导致私有属性覆盖标准属性。因此私有在前，标准在后的写法是考虑到了以后可能会出现的问题。1.m-box&#123;-webkit-box-shadow:0 0 0 #000;-moz-box-shadow:0 0 0 #000;box-shadow:0 0 0 #000;&#125; 选择器等级 !important&gt;行内样式style&gt;id选择器&gt;类、伪类和属性选择器&gt;标签选择器和伪元素选择器 css内部的顺序我认为，对于一个网页而言，我们在写css时，可以分为几个部分来写，比如header部分的css代码，main部分的css代码，部分之间通过空格隔开并给以响应的注释，这样更有利于我们的阅读和后期的维护。 优化方案对于可以缩写的值我们尽量采用缩写形式，这样有利于减小css文件大小，并增加可读性和可维护性。且最好尽量减少没有实际作用的冗余的属性。有时我们会将定义相同的或者有大部分属性值相同的一系列的选择器组合到一起（采用逗号的方法）来统一定义，这样可以为你节省很多字节和宝贵时间。 其他格式要求 在一个规则声明中应用了多个选择器时，每个选择器独占一行 在规则声明的左大括号 { 前加上一个空格 规则声明的右大括号 } 独占一行 在属性的冒号 : 后面加上一个空格，前面不加空格 规则声明之间用空行分隔开 类选择器的命名建议在前面说到，命名className时，应当以其作用、功能来命名，而不要使用没有语义化或者以颜色、左右空间位置的文字来命名。 对于布局，即用.g-作为前缀，通常有以下推荐的写法 头部： header或head 主体： body 尾部：footer或foot 主栏： main 侧栏：side 盒容器： wrap或box 主栏子容器：mainc 侧栏子容器：sidec 对于模块，即.m-作为前缀。元件，.u-作为前缀，通常有下面推荐的写法 导航： nav 子导航：subnav 菜单：menu 选项卡：tab 标题区：head或title 内容区：body或content 列表：list 表格：table 表单：form 排行：top 热点：hot 登录：login 标志：logo 广告：adervertise 搜索：search 幻灯：slide 帮助：help 新闻：news 下载：download 注册：register或regist 投票：vote 版权:copyright 结果：result 按钮：button 输入：input 对于功能，即以.f-为前缀，通常推荐如下： 清除浮动：clearboth 向左浮动：floatleft 向右浮动: floatright 溢出隐藏：overflowhidden 对于颜色，即以.s-为前缀，通常推荐如下： 字体颜色：fontcolor 背景：background 背景颜色：backgroundcolor 背景图片：backgroundimage 背景定位：backgroundposition 边框颜色：bordercolor 对于状态，即以.z-为前缀，通常推荐如下： 选中:selected 当前：current 显示：show 隐藏：hide 打开：open 关闭:close 出错：error 不可用:disabled css分类通常一个页面我们只引用一个css，但是对于较大的项目，我们需要把css文件进行分类。 按照css的性质和用途，我们可以将css文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此为顺序引用。那么他们分别是什么呢？ 公共型样式公共型样式是最为重要的部分，对于比较小的项目，我们只引入一个css，这个css的样式即公共型样式，一般包括：“标签的重置和设置默认值”（以消除不同浏览器之间的差异）、“统一调用背景图和清除浮动或其他需统一处理的长样式（这样就无需对每个进行分别的处理）”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。 特殊型样式特殊型样式即对某个维护率较高的栏目或者某个与网站整体差异较大的页面独立引入这样一个特殊型样式，方便我们维护。 皮肤型样式皮肤型样式即产品需要换肤功能，那么我们就需要将颜色、背景等抽离出来放在这里，方便管理。 重置和默认的css代码这是为了消除默认样式和浏览器的差异，并设置部分标签的初始样式，以减少后面的重复劳动。 你可以根据自己的网站需求设置，也可以使用别人写好的一些初始化代码，比如：雅虎工程师提供的css初始化代码。这一部分代码放在css内部的最上面。 统一处理的css代码这里可以统一调用背景图和清除浮动（指通用性较高的布局、模块、原件内的清楚），实际上，雅虎工程师提供的css初始化代码中就有清除浮动的css代码。这一部分代码放在重置和默认的css代码下面。 布局（grid） 我们将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等。常用！ 模块（module） 即语义化的可以重复使用的较大的整体。如导航、登陆、注册、列表、评论、搜索等。常用！ 元件（unit）通常是一个不可再分的较为小巧的个体，被重复用于各种模块中，比如按钮、输入框、loading、图表等。常用！ 功能（function）为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动。不常用，不可滥用！ 皮肤（skin）对于换肤型网站需要使用，将皮肤型的样式抽离出来，非换肤型网站不可滥用，不常用。 状态即一些状态类样式。不常用。 OOCSS 和 BEM 认识OOCSS，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。 BEM，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的命名约定。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。 出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合： 可以帮助我们理清 CSS 和 HTML 之间清晰且严谨的关系。 可以帮助我们创建出可重用、易装配的组件。 可以减少嵌套，降低特定性。 可以帮助我们创建出可扩展的样式表。 CSS的一些常见操作重置你的CSS样式 normalize： http://necolas.github.io/normalize.css/ reset： http://html5reset.org/http://www.zhangxinxu.com/wordpress/2010/08/html5-css-reset/ 使用主样式表1234567/* master.css */@import url("reset.css");@import url("global.css"); @import url("structure.css");&lt;style type="text/css"media="Screen"&gt; @import url("css/master.css");&lt;/style&gt; CSS调试1* &#123; border: 1px solid #f00; &#125; CSS注释 建议使用行注释 (在 Sass 中是 //) 代替块注释 建议注释独占一行。避免行末注释。 给没有自注释的代码写上详细说明，比如：为什么用到了 z-index 兼容性处理 使用标志。“将样式表分成特定的部分：全局样式 - （正文，段落，列表等），页眉，页面结构，标题，文本样式，导航，表单，注释，附件。 结语年底空一点时间，来整理下CSS相关的一些规范，祝大家新年快乐，狗年大吉！有勘误欢迎斧正！！！相关链接：https://www.cnblogs.com/zhuzhenwei918/p/6104065.htmlhttp://alloyteam.github.io/CodeGuide/#css]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
        <tag>前端</tag>
        <tag>css优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES8新特性整理]]></title>
    <url>%2F2017%2F08%2Fes8%2F</url>
    <content type="text"><![CDATA[前言ES8 或者说是 ES2017 已经在今年6月底的时候被 TC39 正式发布。似乎我们在最近的一年里就已经谈论了很多有关 ECMA 的事情。现在的 ES 标准每年发布一次。我们都知道 ES6 是在2015年发布的，ES7 是在2016年发布的，但是估计会有很少数人知道 ES5 是在何时发布的。答案是2009年，是在 JavaScript 逐渐变的流行之前发布的。 字符串填充在 String 对象中，ES8 增加了两个新的函数： padStart 和 padEnd 。正如其名，这俩函数的作用就是在字符串的头部和尾部增加新的字符串，并且返回一个具有指定长度的新的字符串。 语法： 123str.padStart(targetLength [, padString])str.padEnd(targetLength [, padString]) 这俩函数的第一个参数（必输）是 targetLength ，这个参数指的是设定这俩函数最后返回的字符串的长度。第二个参数 padString 是可选参数，代表你想要填充的内容，默认值是空格。 示例： 1234567891011'es8'.padStart(2); // 'es8''es8'.padStart(5); // ' es8''es8'.padStart(6, 'woof'); // 'wooes8''es8'.padStart(14, 'wow'); // 'wowwowwowwoes8''es8'.padStart(7, '0'); // '0000es8''es8'.padEnd(2); // 'es8''es8'.padEnd(5); // 'es8 ''es8'.padEnd(6, 'woof'); // 'es8woo''es8'.padEnd(14, 'wow'); // 'es8wowwowwowwo''es8'.padEnd(7, '6'); // 'es86666' 浏览器支持情况： Chrome Firefox Edge IE Opera Safari 57 48 15 15 44 10 values和entries函数在 Object 中，ES8 也新增了两个新的函数，分别是 Object.values 函数和 Object.entries 函数。Object.values 函数将会返回一个数组，该数组的内容是函数参数（一个对象）可遍历属性的属性值。数组中得到的属性值的顺序与你在对参数对象使用 for in 语句时获取到的属性值的顺序一致。 Object.values语法： 1Object.values(obj) 参数 obj 就是源对象，它可以是一个对象或者一个数组（因为数组可以看作是数组下标为 key ，数组元素为 value 的特殊对象）。 示例： 1234567891011const obj = &#123; x: 'xxx', y: 1 &#125;;Object.values(obj); // ['xxx', 1]const obj = ['e', 's', '8']; // same as &#123; 0: 'e', 1: 's', 2: '8' &#125;;Object.values(obj); // ['e', 's', '8']// when we use numeric keys, the values returned in a numerical // order according to the keysconst obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.values(obj); // ['yyy', 'zzz', 'xxx']Object.values('es8'); // ['e', 's', '8'] 浏览器支持情况： Chrome Firefox Edge IE Opera Safari 54 47 (yes) No support No support No support Object.entriesObject.entries 函数与 Object.values 函数类似，也是返回一个数组，只不过这个数组是一个以源对象（参数）的可枚举属性的键值对为数组 [key, value] 的 n 行 2 列的数组。它的返回顺序与 Object.values 函数类似。 语法： 1Object.entries(obj) 示例： 123456789const obj = &#123; x: 'xxx', y: 1 &#125;;Object.entries(obj); // [['x', 'xxx'], ['y', 1]]const obj = ['e', 's', '8'];Object.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]const obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']] 浏览器支持情况： Chrome Firefox Edge IE Opera Safari 54 47 (yes) No support No support 10.1 getOwnPropertyDescriptors函数Object 中还有一个新成员，那就是 Object.getOwnPropertyDescriptors 函数。该函数返回指定对象（参数）的所有自身属性描述符。所谓自身属性描述符就是在对象自身内定义，不是通过原型链继承来的属性。 语法： 1Object.getOwnPropertyDescriptors(obj) obj 参数即为源对象，该函数返回的每个描述符对象可能会有的 key 值分别是：configurable、enumerable、writable、get、set和value。 示例： 12345678910111213141516171819const obj = &#123; get es7() &#123; return 777; &#125;, get es8() &#123; return 888; &#125;&#125;;Object.getOwnPropertyDescriptor(obj);// &#123;// es7: &#123;// configurable: true,// enumerable: true,// get: function es7()&#123;&#125;, //the getter function// set: undefined// &#125;,// es8: &#123;// configurable: true,// enumerable: true,// get: function es8()&#123;&#125;, //the getter function// set: undefined// &#125;// &#125; 浏览器支持情况： Chrome Firefox Edge IE Opera Safari 54 50 (yes) ? 41 10 结尾逗号此处结尾逗号指的是在函数参数列表中最后一个参数之后的逗号以及函数调用时最后一个参数之后的逗号。ES8 允许在函数定义或者函数调用时，最后一个参数之后存在一个结尾逗号而不报 SyntaxError 的错误。 示例： 1234567//函数声明时function es8(var1, var2, var3,) &#123; // ...&#125;//函数调用时es8(10, 20, 30,); ES8的这项新特性受启发于对象或者数组中最后一项内容之后的逗号，如 [10, 20, 30,] 和 { x: 1, } 异步函数由 async 关键字定义的函数声明定义了一个可以异步执行的函数，它返回一个 AsyncFunction 类型的对象。异步函数的内在运行机制和 Generator 函数非常类似，但是不能转化为 Generator 函数。 ps: 不理解 Generator 函数的读者可以参考阮一峰大师的ES6入门中关于Generator函数的讲解 示例： 123456789101112function fetchTextByPromise() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("es8"); &#125;, 2000); &#125;);&#125;async function sayHello() &#123; const externalFetchedText = await fetchTextByPromise(); console.log(`Hello, $&#123;externalFetchedText&#125;`); // Hello, es8&#125;sayHello(); 上述代码中， sayHello 函数的调用将会导致在2秒之后打印 Hello, es8 。继续来看一段代码： 123console.log(1);sayHello();console.log(2); 输出将会变成： 1231 // immediately2 // immediatelyHello, es8 // after 2 seconds 之所以会打印上述内容，那是因为异步函数不会阻塞程序的继续执行。 浏览器支持情况： Chrome Firefox Edge IE Opera Safari 55 52 (yes) ? 42 10.1 共享内存与原子操作当内存被共享时，多个线程可以并发读、写内存中相同的数据。原子操作可以确保那些被读、写的值都是可预期的，即新的事务是在旧的事务结束之后启动的，旧的事务在结束之前并不会被中断。这部分主要介绍了 ES8 中新的构造函数 SharedArrayBuffer 以及拥有许多静态方法的命名空间对象 Atomic 。 Atomic 对象类似于 Math 对象，拥有许多静态方法，所以我们不能把它当做构造函数。 Atomic 对象有如下常用的静态方法： add /sub - 为某个指定的value值在某个特定的位置增加或者减去某个值 and / or /xor - 进行位操作 load - 获取特定位置的值 浏览器支持情况： Chrome Firefox Edge IE Opera Safari No support 55 No support No support No support No support 取消模版字符串限制（ ES9 ）使用 ES6 中规定的模版字符串，我们可以做如下事情： 123456789101112131415const esth = 8;helper`ES $&#123;esth&#125; is `;function helper(strs, ...keys) &#123; const str1 = strs[0]; // ES const str2 = strs[1]; // is let additionalPart = ''; if (keys[0] == 8) &#123; // 8 additionalPart = 'awesome'; &#125; else &#123; additionalPart = 'good'; &#125; return `$&#123;str1&#125; $&#123;keys[0]&#125; $&#123;str2&#125; $&#123;additionalPart&#125;.`;&#125; 上述代码的返回值将会是 ES 8 is awesome 。如果 esth 是 7 的话，那么返回值将会是 ES 7 is good 。这样做完全没有问题，很酷！但是我们在使用模版字符串的时候，有一个限制，那就是不能使用类似于 \u 或者 \x 的子字符串， ES9 正在处理这个问题。详情请查阅MDN或者TC39文档。 浏览器支持情况： Chrome Firefox Edge IE Opera Safari No support 53 No support No support No support No support 转自：Github-ES8 新特性一览]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es8</tag>
        <tag>es6</tag>
        <tag>es9</tag>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0最全入坑指南(组件初识篇)]]></title>
    <url>%2F2017%2F08%2Fvue2-2%2F</url>
    <content type="text"><![CDATA[前言接上一篇入坑指南(配置篇)，我们已经认识了vue的基本结构，大的骨架vue-cli已经帮我们准备好了，本篇来看看vue强大的组件(Component)。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 目录结构整理 以我的个人博客为例，大致可分为三部分组成，页头、内容、页脚。在vue里面这三部分都可以写成组件来使用。正常情况下，我们的第一思路就是在components内分别新建三个组件，然后在我们的app.vue分别引用这三个组件就可以实现一个简单的三栏页面。实际应用的时候为了区分入口页面与实际应用组件的区别，src下面我们大致可以划分如下： 1234567891011121314151617181920212223242526272829src assets ---less ---xxx.less ---img ---xxx.png ---js ---xxx.js components //可复用组件 ---common ---footer.vue ---header.vue ---content ---index.vue ---tags ---index.vue router ---index.js views //页面组件 ---home.vue ---tags.vue ---404.vue ---xxx.vue vuex ---actions.js ---mutation-types.js ---store.js App.vue main.js PS：以上目录结构根据各大github实际项目综合而来，仅供参考。实际项目中请自行调整目录结构！！！ 我的第一个组件header.vue下面开始编写我的第一个组件header.vue，按照上面的目录在common下新建header.vue，代码如下： 1234567891011121314151617181920&lt;template lang="html"&gt; &lt;!-- 默认为html模版 --&gt; &lt;div class="head-box"&gt;&lt;!-- 组件模板必须包括一个共同的根元素，因此定义了一个根元素div --&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:"headTop", data()&#123; //data必须是一个函数 return&#123; msg:'这里是页头' &#125; &#125; &#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;&lt;/style&gt; PS:用相同的方法，分别创建footer.vue,content/index.vue备用，在这里需要注意的是组件模板必须包括一个共同的根元素，因此定义了一个根元素div，data必须是一个函数，参考官网说法，其他相关的template、script、style作用这里就不多说了，参考上一篇文章vue配置篇 组件的使用上面分别建了三个组件，header.vue,footer.vue,content/index.vue,现在它们是单一的组件模块，需要我们像搭积木一样组装起来发挥它们的作用。在views下面新建home.vue，如下： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class="home-box"&gt; &lt;!--组件使用--&gt; &lt;head-div&gt;&lt;/head-div&gt; &lt;content-div&gt;&lt;/content-div&gt; &lt;foot-div&gt;&lt;/foot-div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //导入组件 import headDiv from '@/components/common/header' import footDiv from '@/components/common/footer' import contentDiv from '@/components/content' export default &#123; name:"home", data()&#123; return&#123; &#125; &#125;, components:&#123; //组件注册 headDiv, footDiv, contentDiv &#125; &#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;&lt;/style&gt; PS:组装好了 然后运行cnpm run dev命令 查看效果，不出意外在浏览器就可以看到一个简单的三栏页面。此时一个简单页面就组装完成了。对于自定义标签名，Vue.js 不强制要求遵循 W3C 规则 (小写，并且包含一个短杠)，尽管遵循这个规则比较好 分离公共组件在正常使用中，我们的页头、页脚基本是不变的，所以这块可以提取出来，放入app.vue做为固定加载。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id="app"&gt; &lt;div class="mid-col"&gt; &lt;!-- &lt;img src="/static/logo.jpg"&gt; --&gt; &lt;!-- 加载公共头部信息 --&gt; &lt;head-div&gt;&lt;/head-div&gt; &lt;!-- 引用静态资源文件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 这里是用来展示路由页面内容的，如果想用跳转就用&lt;router-link to='xxx'&gt;&lt;/router-link&gt; --&gt; &lt;!-- 加载公共页脚信息 --&gt; &lt;foot-div&gt;&lt;/foot-div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import headDiv from '@/components/common/header'import footDiv from '@/components/common/footer'export default &#123; name: 'app', data()&#123; return&#123; &#125; &#125;, components:&#123; headDiv, footDiv &#125;&#125;&lt;/script&gt;&lt;style lang="less"&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; // color: #2c3e50; /*margin-top: 60px;*/ position: relative; min-height: 100%; height: 100%;&#125;&lt;/style&gt; 写好运行cnpm run dev查看效果，结果与之前一致。 结语本篇我们讲了组件的基本结构，区分了页面组件、应用组件。从第一个组件的创建到完整组件的使用，理解了组件是怎么运转的。建议结合vue官网加实例来学习组件。后面会继续分析组件的常用方法、属性等。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Vue</tag>
        <tag>vue2.0</tag>
        <tag>前端框架</tag>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>vue组件</tag>
        <tag>vue入坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0最全入坑指南(配置篇)]]></title>
    <url>%2F2017%2F08%2Fvue2-1%2F</url>
    <content type="text"><![CDATA[前言距离上一篇vue文章快一个月了，最近在忙项目，有点时间又上来继续更新。本篇主要介绍vue项目的脚手架文件，具体是做什么用的？了解清楚结构，对后面的开发也有极大的帮助。 目录梳理 build — 目录是一些webpack的文件，配置参数什么的，一般不用动config — 是vue项目的基本配置文件node_modules — 是项目中安装的依赖模块src — 源码文件夹，基本上文件都应该放在这里。 assets — 资源文件夹，里面放一些常见资源 components — 这里放的都是各个组件文件 router — vue路由模块 App.vue — App.vue组件 main.js — 入口文件 static — 静态文件夹，放一些图片\js\css等test — 测试文件夹，测试都写在这里.babelrc — babel编译参数，vue开发涉及到一些es6的语法.editorconfig — IDE配置文件，常见的格式处理.gitignore — 用来过滤一些版本控制的文件，比如node_modules文件夹.postcssrc.js — 自动补全css浏览器前缀index.html — 主页package.json — 项目文件，记载着一些命令和依赖还有简要的项目描述信息README.md — 项目说明书，用markdown写的。不会写就参照github上star多的项目，看人家怎么写的 PS:可能大家看到我的截图没有node_modules文件夹，这是我IDE把它屏蔽掉了。 文件说明config/index.js 这里主要针对dev配置做下说明，因为这块是我们常用的，上面的build设置类似。如下： 1234567891011121314dev: &#123; env: require('./dev.env'), //引用测试环境配置 port: 8000, //端口号 autoOpenBrowser: false, //是否打开浏览器 assetsSubDirectory: 'static', //静态资源引用目录 assetsPublicPath: '/', //静态资源引用路径设置 proxyTable: &#123;&#125;, //代理设置，很好的解决了跨域问题 // CSS Sourcemaps off by default because relative paths are "buggy" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false //是否生成css sourceMap文件 &#125; Hello.vue在components文件夹下有一个Hello.vue，这是我们的第二个vue组件。这不是只有一个么，是的。在我们的根目录下面还有一个app.vue 这也是一个组件。不同的是 app.vue相当与父组件，而Hello.vue相当于子组件。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;!-- 这里是展示数据的 --&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://tigerliu.site/" target="_blank"&gt;Tiger Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/tiger6" target="_blank"&gt;github&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hello', /* 这个name暂时不知道用啥用 */ data () &#123; return &#123; /* 这里是数据，一定记住数据一定要放data中然后用return返回 */ msg: 'Welcome to Your' &#125; &#125;&#125;&lt;/script&gt;&lt;!--添加“scoped”属性，仅将CSS限制为该组件 --&gt;&lt;style lang='less' scoped&gt;/*scoped的意思是这里的样式只对当前页面有效不会影响其他页面，还有可以设置lang="scss"就是支持css预编译，也就是支持sass或者less*/h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; PS:在*.vue文件，template标签里写html代码，且template直接子级只能有一个标签。style标签里写样式，script里面写js代码 router/index.js vue路由配置页123456789101112131415import Vue from 'vue' /* 引用vue文件 */import Router from 'vue-router' /* 引用vue路由模块，并赋值给变量Router */import Hello from '@/components/Hello' /* 英文Hello.vue模版，并赋值给变量Hello,这里是“@”相当于“../” */Vue.use(Router) /* 使用路由 */export default new Router(&#123; routes: [ /* 进行路由配置，规定“/”引入到Hello组件 */ &#123; path: '/', name: 'Hello', /* 这个name用来匹配路由跳转，例如: :to="&#123;name:'hello'&#125;" */ component: Hello /* 注册Hello组件 */ &#125; ]&#125;) App.vue 这是一个标准的vue组件，包含三个部分，一个是模板(template)，一个是script，一个是样式(style)12345678910111213141516171819202122232425&lt;template&gt; &lt;div id="app"&gt; &lt;img src="/static/logo.jpg"&gt; &lt;!-- 引用静态资源文件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 这里是用来展示路由页面内容的，如果想用跳转就用&lt;router-link to='xxx'&gt;&lt;/router-link&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; PS: &lt;img src=&quot;/static/logo.jpg&quot;&gt;引用static文件夹下的资源。这里有必要说下assets与static的区别，assets放置的是组件的资源，static放置的是非组件的资源。比如上面的图片引用，assets文件夹的图片会被 webpack打包到一起，而static文件夹是浏览器直接去请求图片文件。 main.js这个js文件是主页面配置的主入口,可以引入一些插件或静态资源(引入前需先安装)。主要是利用es6的模块化引入模块。12345678910111213import Vue from 'vue' /* 这里是引入vue文件 */import App from './App' /* 这里是引入同目录下的App.vue模块 */import router from './router'/* 这里是引入vue的路由 */Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app',/* 定义作用范围就是index.html里的id为app的范围内 */ router,/* 引入路由 */ template: '&lt;App/&gt;',/* 给Vue实例初始一个App组件作为template 相当于默认组件 */ components: &#123; App &#125;/* 注册引入的组件App.vue */&#125;) index.html主页的html跟我们平常的无异，引入文件，书写基本信息，添加meta标签等。这里id=’app’，是为后面的设置vue作用域有关。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 兼容移动端 --&gt; &lt;meta name="viewport" content="user-scalable=no, width=device-width,initial-scale=1,minimum-scale=1"&gt; &lt;meta name="screen-orientation" content="portrait"/&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;!-- 全屏设置 --&gt; &lt;meta name="full-screen" content="yes"&gt; &lt;meta name="x5-fullscreen" content="true"&gt; &lt;title&gt;vue2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; package.jsonpackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成。12345678910111213141516171819202122232425262728293031323334&#123; "name": "vue2", //项目名称 "version": "1.0.0", //版本 "description": "A Vue.js project", //描述信息 "author": "tiger6", //作者 "private": true, //私有项目 "scripts": &#123; //项目的生命周期个各个环节需要执行的命令 "dev": "node build/dev-server.js", "start": "node build/dev-server.js", "build": "node build/build.js", "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run", "e2e": "node test/e2e/runner.js", "test": "npm run unit &amp;&amp; npm run e2e" &#125;, "dependencies": &#123; //生产阶段依赖的模块列表 "vue": "^2.3.3", "vue-router": "^2.6.0" &#125;, "devDependencies": &#123; //开发环境依赖的模块列表 "autoprefixer": "^7.1.2", "babel-core": "^6.22.1", "babel-loader": "^7.1.1" //..............省略其他模块.................. &#125;, "engines": &#123; //node/npm版本支持 "node": "&gt;= 4.0.0", "npm": "&gt;= 3.0.0" &#125;, "browserslist": [ //浏览器支持的版本 "&gt; 1%", "last 2 versions", "not ie &lt;= 8" ]&#125; 项目源代码参考：tiger-vue2 结语总结下，如果需要增加组件那就在components文件下定义xx.vue文件并编写代码即可，如果需要配置路由就要进行在index.js进行路由“路径”配置，如果需要点击跳转就要用到标签了。如果需要增加less/sass css预编译支持，先安装然后在需要用到的地方style标签加上lang=”less”或者lang=”scss”就好了。其他组件库，UI组件使用 方法类似，先安装再导入使用。后面将会分析vue组件,vue路由，vuex等文章。有问题欢迎页脚留言，谢谢！！！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Vue</tag>
        <tag>vue2.0</tag>
        <tag>前端框架</tag>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>vue入坑</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶高级教程（三）]]></title>
    <url>%2F2017%2F07%2Fhexo-3%2F</url>
    <content type="text"><![CDATA[前言继今年6月日关闭“网易多说”评论系统后，第三方评论系统——网易云跟帖也宣布将于2017年8月1日停止服务，而且理由同样是因公司业务发展需要。网易云跟帖关闭后，第三方评论系统也只剩下友言、搜狐畅言、韩国来必力(支持英语、中文、韩语)等少数几个。本文围绕这三个评论系统做一个简单的介绍。（本文示例均为next主题） PS：为何用next主题来说，因为next主题帮我们融合了各大评论系统，只需要我们配置id/key值就可以使用了，超级方便！！！其他主题需要自行配置评论插件，才能使用。若是有朋友用到spfk主题，可在下方留言。博主有现成的网易云、畅言、来必力评论插件。 友言链接：友言之前也不知道这个评论系统，后来在写博客的时候，看到同事在用，于是乎也注册了一个。 注册、登录点击后台管理 进来你可以获取到一个用户ID–复制 如下图：打开主题（next）根目录配置文件_config.yml 搜索youyan 打开注释设置UID123# Support for youyan comments system.# You can get your uid from http://www.uyan.ccyouyan_uid: your uid hexo g hexo s 运行 查看效果 如下图： 友言HTML代码块 PS:这UI没法跟云跟帖比，很low 重要的是上图的iframe内嵌，是博主不喜欢的。因为博主一直使用spfk主题（黑色），DIY方面根本无从下手，在友言后台设置里面也未找到可以设置的地方。 后台数据导入 PS: 在数据导入方面从云跟帖导出的数据，这里根本无法使用。格式不对，然而博主又修改正确的格式，导入依然不行。故而弃之！！！ 畅言链接：搜狐畅言2013年12月10日，搜狐旗下社会化评论系统与聚合平台–畅言宣布，通过SDK将社会化评论服务延伸至APP内，率先推出评论SDK和互动SDK，正式开启社会化评论系统进军移动端的进程。不得不说在国内畅言是做的最好最稳定的，背后依托搜狐大公司背景，安全性、保密性都能得到保证。 注册、登录进入后台管理系统，我们可以看到待审评论、未读通知、广告收益、昨日评论概况，下面可以获取到app id、app key 复制下来备用。 配置打开主题下的配置文件，搜索changyan就出来了，填上刚才的appid、appkey,enable设置为true.12345# changyanchangyan: enable: true appid: cytxxx appkey: 670c68exxxxxxxxx 配置好了，注释掉其他评论系统代码块，运行hexo s 直接查看本地效果。如图： 数据导入支持多说、友言、网易云数据导入： PS：效果自然不用说了，老牌评论系统各种功能应有尽有，在国内是最好的选择。可是它在注册的时候，需要我们输入备案号，也就是说我们的网站需要备案，没备案可以试用15天。这就尴尬了，我们的网站是托管在github或者是coding上面的这根本没法备案，这需要有自己的云主机或者服务器托管博客，打算长期写博文的同学可以考虑，否则另谋他路吧！！！ 来必力链接：来必力来必力是韩国的一款社会化评论服务，它的完成度很高，拥有和多说类似的功能，而且非常美观，看历史也不是很快就会死的服务。支持英语、中文、韩语。不是说它多好多好，其实博主还是一直支持国产，走投无路时也是一个折中的选择。。 注册（需要翻墙），它有两个版本： City 版：是一款适合所有人使用的免费版本； Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本； PS:最好是用中文版的注册，注册这里博主到没遇到啥问题，反而在登录的时候 死活登录不上去，账号密码都对，因为它的报错信息是韩文的，真不知道这国际化是怎么做的，后来用翻译工具翻译一遍才登上去（中间发了一个验证码到邮箱，输入该验证码就好了）。如果经常使用的话，建议不要注销登录，也可以用浏览器记住密码方便下次登录。。。 登录后点击右上角管理页面–》左侧代码管理 然后可以看到一般网站的安装方法，复制data-uid备用.如图打开主题下的配置文件搜索livere 填写livere_uid123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMxxxxxx 注释掉其他评论系统，然后hexo s查看效果： 评论管理 PS:这里不知道为何日期是undefined。。。。在页面上显示是正常的 提醒功能这个功能还是蛮方便的，之前在用云跟帖的时候，查看最新评论信息我们还得去后台管理系统（不要碧莲哪有 哈哈。。。） 开启此功能，设置好邮箱，提醒时间 就好了！！！ SNS选择可以设置第三方系统登录来必力，顺序是可以拖动排列的，试了下来必力的图标是没法拖动的（不要这么幼稚），博主这里全选了。。。。 DIY设置这个功能对于博主来说，真的非常适用，虽然也是iframe没法修改，但是至少有选择的余地。下面有6种方案可选，可自行调整合适的风格（调完可以点下面的提前查看，预览当前设置）。。。如图： 数据导入这里不支持国内的评论系统数据导入（博主没找到）,毕竟是别人家的东西。。。。有知道的请告诉我。。。 结语多说之前只是听说过，还没用就挂掉了，暂且不谈。网易云跟帖是博主用的第一个评论系统，用了1个多月的样子也相继沦陷。被迫选择其他出路，友言上面也说到了，UI风格不是我想要的。畅言需要我们备案备案备案。。。扎心了老铁。。。特么只剩下一个来必力了，还特么是别人家的孩子。。。。有任何疑问欢迎斧正，谢谢！！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>comments</tag>
        <tag>hexo评论</tag>
        <tag>友言</tag>
        <tag>畅言</tag>
        <tag>来必力</tag>
        <tag>网易云跟帖</tag>
        <tag>多说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探基于React+Redux前端应用框架Dva]]></title>
    <url>%2F2017%2F07%2Fdva%2F</url>
    <content type="text"><![CDATA[前言众所周知，react的学习成本是较高的，而antd推出的这款框架，大大的降低了react的学习成本。dva 是对 redux 的一层浅封装，所以虽然我们不要求一定要了解 redux 才能学会使用 dva，但是如果你对 redux 有所了解，再使用 dva 一定驾轻就熟，并且会了解很多潜在的知识点。下面一起看看如何快速搭建dva项目。 安装node.js/git未安装node.js、git的同学请戳这里Node本地环境搭建 安装 dva-cli那么，首先需要安装的是 dva-cli 。dva-cli 是 dva 的命令行工具，包含 init、new、generate 等功能，目前最重要的功能是可以快速生成项目以及你所需要的代码片段。1$ npm install -g dva-cli 安装完成后，可以通过 dva -v 查看版本，以及 dva -h 查看帮助信息。 创建新应用，new的使用安装完 dva-cli 后，我们用它来创建一个新应用，取名 myApp。1$ dva new myApp --demo 注意：–demo 用于创建简单的 demo 级项目，正常项目初始化不加要这个参数。 然后进入项目目录，并启动。12$ cd myApp$ npm start 几秒之后，会看到这样的输出：12345678910111213&gt; @ start D:\xxx\myApp&gt; roadhog serverStarting the development server...Compiled successfully!The app is running at: http://localhost:8000/Note that the development build is not optimized.To create a production build, use npm run build. (如需关闭 server，请按 Ctrl-C.) 在浏览器里打开 http://localhost:8000/ ，正常情况下，你会看到一个 “Hello Dva” 页面。 初始化项目，init的使用new创建的项目比较简单，为了满足实际开发需求，我们可以使用init来初始化。123mkdir dvacd dvadva init 在我们初始化的时候，dva已经帮我们安装了依赖，所以我们可以直接运行看效果。 1$ npm start 在浏览器里打开 http://localhost:8000/，正常情况下，你会看到如下效果： 端口号修改在开发中，我们会同时开发两个或多个项目，这个时候就会遇到端口冲突的问题，如何修改呢？ roadhog serverroadhog默认的端口号是80001234&gt; @ start D:\xxx\dva&gt; roadhog serverSomething is already running on port 8000. 上面代码显示端口号被占用，打开我们的配置文件package.json 修改scripts下的start,如下：1234567// OS X, Linux"scripts": &#123; "start": "PORT=3000 roadhog server", // Windows (cmd.exe)"scripts": &#123; "start": "set PORT=3000&amp;&amp;roadhog server", 修改完再运行npm start 一切正常。 dora默认端口8989,同样在package.json下修改start12"scripts": &#123; "start": "dora -p 7001 --plugins \"proxy?port=8888,webpack,webpack-hmr\"", 结语前端的世界变化太快，一不小心又OUT了。关于dva的项目搭建就说到这里，有任何疑问可在下面留言一起探讨。 相关链接：dva githubroadhog知乎日报，基于dva脚手架dva实例antd-admin]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>react</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0最全入坑指南(初识篇)]]></title>
    <url>%2F2017%2F07%2Fvue2%2F</url>
    <content type="text"><![CDATA[前言Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 安装node.js/git未安装node.js、git的同学请戳这里Node本地环境搭建 安装webpack(选装)1npm install webpack -g 输入webpack -v版本检测：123xxx@xxx-PC MINGW64 /$ webpack -v3.1.0 PS: -g 代表全局安装，最新的 vue 项目模板中，都带有 webpack 插件，所以这里可以不安装 webpack 安装vue-cli1npm install vue-cli -g 输入vue -V(大写)安装检测：12345xxx@xxx-PC MINGW64 /$ vue -V2.8.1xxx@xxx-PC MINGW64 /$ PS: 正确输出版本号代表安装成功,如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，可以使用 npm install -g npm 来更新版本 vue项目初始化在你喜欢的目录下新建文件夹，例如（D:\vue2）,cd 切换至该目录vue init webpack xxx-project(项目名称)，默认回车安装12cd d:/vue2vue init webpack PS:安装到Use ESLint to lint your code?这里的时建议选N,如果为Yes在我们编写程序的时候会严格按照ESLint语法进行检测，很容易出错。运行到Documentation can be found at https://vuejs-templates.github.io/webpack 可以按Ctrl+C退出 安装依赖包1npm install或cnpm install(推荐) PS：等待几分钟。。。cnpm较快建议使用 运行第一个vue项目接下来执行npm run dev1npm run dev或cnpm run dev 效果： PS:看到上面的界面，就代表我们的第一个vue运行成功了！！！ 错误处理： 看到上面的错误信息，可以断定咱们的端口号被占用了。 修改端口号：config&gt;index.js—-&gt;port:8000，然后再运行npm run dev 打上线包项目开发完成之后，可以输入 cnpm run build 来进行打包工作1cnpm run build PS:打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看 项目上线时，只需要将 dist文件夹放到服务器就行了 结语到这里我们已经初步体验了一把vue2.0,是不是感觉也没那么复杂,本篇为初识篇，后面将会在本博客继续我们的vue2入坑之旅,请持续关注本博客Tigerliu Blog，喜欢可收藏分享！！！ vue相关链接：vue中文官网vue中文社区vue中文APIvue中文教程vue菜鸟教程]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Vue</tag>
        <tag>vue2.0</tag>
        <tag>前端框架</tag>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>vue入坑</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node本地环境搭建]]></title>
    <url>%2F2017%2F07%2Fnode%2F</url>
    <content type="text"><![CDATA[前言考虑到很多小伙伴，本地没有node环境，故做一些环境说明。 文件下载 node-v6.4.5-x64或以上 Node.js下载Git-1.9.5-preview20150319或以上 Git下载 node.js安装百度搜索node.js或点击上面的Node.js下载链接,在官网下载新版node.js（LTS稳定版），如图：下载下来应该是一个msi文件，点击安装，一路默认下一步就OK了。 PS：（windows的安装msi文件在过程中会直接添加path的系统变量，变量值是你的安装路径，例如“C:\ProgramFiles\nodejs”） 版本检测：安装完成后可以使用cmd（win+r然后输入cmd进入）测试下是否安装成功。方法：在cmd下输入node -v，出现下图版本提示就是完成了NodeJS的安装。1234567C:\Users\xxx&gt;node -vv6.11.0C:\Users\xxx&gt;npm -v3.10.10C:\Users\xxx&gt; git安装将上面下载的git文件安装到电脑上，一路默认下一步就好了. npm安装由于新版的NodeJS已经集成了npm，所以之前npm也一并安装好了（上面检测正确可跳过）。若检测不到npm版本，打开git命令行窗口，使用下边命令下载npmgit下载地址：1git clone --recursive git://github.com/isaacs/npm.git 下载完成后，打开nodejs命令行窗口(开始–》Node.js–&gt;Node.js command prompt)，进入到npm的代码文件夹下，使用下边命令安装1node cli.js install npm -gf PS:其中-gf是指全局安装的意思，你可以不要，这样会安装在当前文件夹下. cnpm安装淘宝镜像（选装）因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。淘宝镜像官网运行下面命令安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org node环境测试打开git命令行窗口 开始–》Git–》第一个命令Git Bash–》node -v ,npm -v,git –version,cnpm -v 查看安装版本，如下：123456789101112131415161718xxx@xxx-PC MINGW64 /$ node -vv6.11.0xxx@xxx-PC MINGW64 /$ npm -v3.10.10xxx@xxx-PC MINGW64 /$ git --versiongit version 2.13.2.windows.1xxx@xxx-PC MINGW64 /$ cnpm -v4.4.2xxx@xxx-PC MINGW64 /$ PS:至此你本地的node环境已经安装成功，接下来就可以愉快的玩耍了！！！遇到任何问题，可在页尾留言！！！]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>环境搭建</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见字符串拼接方式(JAVA篇)]]></title>
    <url>%2F2017%2F07%2Fstring2%2F</url>
    <content type="text"><![CDATA[前言在java中常用的字符串拼接方法，以及对性能的评测，下面是用Junit写的单元测试。（转） 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.ArrayList;import java.util.List;import org.apache.commons.lang.StringUtils;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TestString &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Test public void testPlus() &#123; String s = ""; long ts = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; s = s + String.valueOf(i); &#125; long te = System.currentTimeMillis(); logger.info("+ cost &#123;&#125; ms", te - ts); &#125; @Test public void testConcat() &#123; String s = ""; long ts = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; s = s.concat(String.valueOf(i)); &#125; long te = System.currentTimeMillis(); logger.info("concat cost &#123;&#125; ms", te - ts); &#125; @Test public void testJoin() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long ts = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; list.add(String.valueOf(i)); &#125; StringUtils.join(list, ""); long te = System.currentTimeMillis(); logger.info("StringUtils.join cost &#123;&#125; ms", te - ts); &#125; @Test public void testStringBuffer() &#123; StringBuffer sb = new StringBuffer(); long ts = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; sb.append(String.valueOf(i)); &#125; sb.toString(); long te = System.currentTimeMillis(); logger.info("StringBuffer cost &#123;&#125; ms", te - ts); &#125; @Test public void testStringBuilder() &#123; StringBuilder sb = new StringBuilder(); long ts = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; sb.append(String.valueOf(i)); &#125; sb.toString(); long te = System.currentTimeMillis(); logger.info("StringBuilder cost &#123;&#125; ms", te - ts); &#125;&#125; 结果：1234511:00:22,359 INFO TestString:23 - + cost 1828 ms11:00:22,921 INFO TestString:34 - concat cost 562 ms11:00:22,937 INFO TestString:46 - StringUtils.join cost 16 ms11:00:22,968 INFO TestString:58 - StringBuffer cost 31 ms11:00:23,031 INFO TestString:70 - StringBuilder cost 63 ms PS:StringBuilder 循环的次数是其它的10倍，如果是一样，那么返回 0，可见StringBuilder 的速度之快。 结语用+的方式效率最差，concat由于是内部机制实现，比+的方式好了不少。Join 和 StringBuffer，相差不大，Join方式要快些，可见这种JavaScript中快速拼接字符串的方式在Java中也非常适用。StringBuilder 的速度最快，但其有线程安全的问题，而且只有JDK5支持。转自：Java 5种字符串拼接方式性能比较]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见字符串拼接方式(JS篇)]]></title>
    <url>%2F2017%2F07%2Fstring1%2F</url>
    <content type="text"><![CDATA[前言在js中经常把两个或多个字符串拼接在一起，常见的”+”，”join”,”\”,”concat”,”`”五种方式，下面一起来看看用法及评测。（本文只做简单整理归纳） 用连接符“+”把要连接的字符串连起来用法：利用“+”把需要连接的字符串连起来 例如：1234var key='left: 0;'+ 'padding-left: 5px;'; key+='font-size: 16px;'; console.log(key); 效果：1left: 0;padding-left: 5px;font-size: 16px; PS：毫无疑问，这种方法是最便捷快速的，如果只连接100个以下的字符串建议用这种方法最方便，有个不好的地方，常常会因为少写或者多写引号而出错，而且这种出错不易察觉 以数组作为中介用 join 连接字符串用法：join() 方法用于把数组中的所有元素放入一个字符串 例如：1234567var a=" padding-left: 5px;font-size: 16px;"var b="color: #fff;background-image: ";var arr=new Array();arr.push(a);arr.push(b);var str=arr.join("");console.log(str); 效果：1padding-left: 5px;font-size: 16px;color: #fff;background-image: PS：w3school 网站介绍说这种方法要比第一种消耗更少的资源，处理大量字符串拼接速度快, 原理在调用join()方法时才发生连接操作 使用转义字符”\”用法：在每一行的最后，都加上转义斜线\ 例1：12345678910var key='left: 0;\ padding-left: 5px;\ font-size: 16px;\ color: #fff;\ background-image: ';console.log(key); ``` 效果：```javascriptleft: 0; padding-left: 5px; font-size: 16px; color: #fff; background-image: 例2：123456789var html='\&lt;h1&gt;\js字符串拼接\&lt;/h1&gt;\&lt;a href="javascript:;" onclick="alert(\'js转义\')"&gt;js转义使用&lt;/a&gt;\&lt;br/&gt;\hello \'world\'\';console.log(html); 效果：1&lt;h1&gt;js字符串拼接&lt;/h1&gt;&lt;a href="javascript:;" onclick="alert('js转义')"&gt;js转义使用&lt;/a&gt;&lt;br/&gt;hello 'world' 还是上面的例子，在&lt;br/&gt;\后面加个空格试试，如图：1Uncaught SyntaxError: Invalid or unexpected token PS:在字符串中，”\”转义符可以将回车转义掉（也就是回车符不存在了），但是不能将制表符，以及空格字符转义（它们是存在的），所以在使用的时候注意空格、回车符。 使用字符串的concat函数用法：concat() 方法用于连接两个或多个字符串 例如：123var str1="Hello "var str2="world!"document.write(str1.concat(str2)) 效果：1Hello world! PS：W3school的提示，使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些。 使用es6模版字符串方法用法：使用键盘1左边的字符 拼接 例如：123456789101112var key=`left: 0; padding-left: 5px; font-size: 16px; color: #fff; background-image: `;console.log(key);var str1 = 'hello'; console.log(`$&#123;str1&#125; world`); var a = 10; var b = 20; console.log(`a+1=$&#123;a+1&#125;;b*2=$&#123;b*2&#125;`); 效果：1234567left: 0; padding-left: 5px; font-size: 16px; color: #fff; background-image: hello worlda+1=11;b*2=40 PS:由上可以看出模版字符串换行不用加号拼接，可以用${}传入变量，可以进行数字的运算在兼容性方面： 服务器端， io.js 支持浏览器端， FF34+ , chrome 41+移动端 IOS 8, Android 4.4IE Tech Preview 结语关于性能测评可以参考JS中三种字符串连接方式及其性能比较拼接字符串的方法及性能比较从性能测评当中“+”并不会比join慢多少，甚至更好用，第三、第五未测试，感兴趣的同学可以自行测试。很多人说ES6的模版字符串用的很爽，若不考虑兼容性的话，简直不要太爽，谁用谁知道。在此只做一个简单归纳，仅为个人意见，到底如何有待进一步验证！！！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>String</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶高级教程（二）]]></title>
    <url>%2F2017%2F06%2Fhexo-2%2F</url>
    <content type="text"><![CDATA[前言接上一篇Hexo 进阶高级教程(一)继续探讨 Hexo,主要的功能都有了，要想让整个博客更丰富，访问速度更快更流畅，就需要添加一些附加的功能，做一些优化处理。下面会讲解： 七牛云图床–用来做图片存储管理 SEO 优化–让更多的人通过搜索引擎搜到我们 网易云跟帖–文章的留言区 leancloud 阅读统计–统计阅读量 百度、谷歌统计–网站流量统计 本文地址：http://tigerliu.site/2017/06/hexo-2 七牛云图床在写博文的时候，难免都会添加一些图片在文章内，正常情况下，我们都使用外链形式添加到我们的博文，为什么要选七牛云呢？让我们来看看它的特点： 10G 免费流量（图片尽量压缩 200k 以内） 服务稳定（写作才是核心，就别总折腾图片的事情了） 便宜（就算付费也相对比较便宜，作为学生党觉得可以接受） 注册七牛云永远不变的第一步，骚年得先去注个册，有了 ID 才能继续玩，链接：七牛云注册 ，按照提示一步一步来就好了。 PS：登录七牛云，验证邮箱， 实名认证 ，可选择支付宝实名认证–前提是你支付宝已经实名认证 ，正常情况下 支付宝实名认证 即刻就可以通过（推荐） 创建对象存储登录七牛云，默认进来就是资源主页，然后在七牛云官方资源栏–》对象存储 点击立即添加，如下图：按照提示填写好存储空间名称，存储区域默认就好了，访问控制–选择公开空间 PS：选择私有空间 需要有 Key 值才能访问，这里选择公开空间 上传完后 直接就可以获取外链 比较方便 上传图片，获取外链选择内容管理–》点击上传文件 ，上传完成之后 点关闭，回到列表页就可以看到刚才上传的图片了鼠标悬浮在文件名上 可点击蓝色的笔重命名，右边的眼睛 Icon 点击 可以获取外链地址，复制外链就可以使用了。 新增图片样式图片样式–》新建图片样式 根据不同业务需要选择场景–》选择合适的缩放方式，是否剪裁，图片水印 这个功能用的比较多（可设置图片水印，文字水印），设置输出格式，然后保存样式。给处理样式命名， 点击下面的保存按钮。我们看到右侧的处理代码，这个是干嘛的呢？我们保存完了之后又怎么使用呢？博主刚开始也是一脸懵逼，复制这段代码，打开刚才上传的图片外链，然后在地址后面用连接符?加上处理的代码，回车就可以看到我们的图片已经加上了水印。不加处理代码就是我们的原图。 123//图片外链?处理代码或者样式名称//示例：http://orzlwnnoa.bkt.clouddn.com/logo.jpg?watermark/2/text/5LiD54mb5LqR/font/5a6L5L2T/fontsize/240/fill/IzAwMDAwMA==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim 与极简图床的结合在写博客的时候，每次都要做这样重复的操作，有没有一键上传并且获取外链的方式呢，必须有啊。这里介绍下极简图床与七牛云的结合。打开极简图床 注册，登录 点击右侧的小齿轮 绑定七牛云账号信息 空间名称：填写在创建对象存储时的空间名称 域名：拷贝外链默认域名 AK: 点击左侧的导航栏个人中心–》密钥管理 获取 AK 信息 SK:点击左侧的导航栏个人中心–》密钥管理 获取 SK 信息点击保存就 OK 了，极简支持截图粘贴，拖拽或者点击上传，上传完可以复制链接/MD 链接生成/预览, 有木有很赞，省了很多事！！！ SEO 优化SEO 是由英文 Search Engine Optimization 缩写而来， 中文意译为“搜索引擎优化”！SEO 是指通过对网站进行站内优化(网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 除开站外 SEO，我们能做的有两方面。一是针对个人网站的页面排版进行 SEO 的优化；二是针对搜索引擎进行主动的优化。 SEO 准备工作 sitemap 插件安装 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 修改博客配置文件在根目录配置文件_config.yml 中修改 url 为你的站点地址 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://tigerliu.siteroot: / 执行完之后就会在网站根目录生成 sitemap.xml 文件（搜索引擎通用文件）和 baidusitemap.xml 文件（百度专用文件），然后执行 hexo d -g 提交到我们站点，打开链接http://tigerliu.site/sitemap.xml 查看该文件是否能正确访问。 添加蜘蛛协议 robots在根目录 source 文件下新建 robots.txt 文件，添加以下文件内容（将 Sitemap 中的域名切换成自己网站域名） 12345678910111213# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://tigerliu.site/sitemap.xmlSitemap: http://tigerliu.site/baidusitemap.xml 参数说明： User-agent: * 允许所有 robot 访问，Allow 允许访问 X 目录，Disallow 禁止访问 X 目录 出站链接添加 “nofollow” 标签nofollow 标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。以 next 主题为例： 1.themes/next/layout/_partials 目录 修改 footer.swig 文件,将下面代码中的 a 标签 加上 rel=”external nofollow” 属性 123456&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt; 2.themes/next/layout/_macro 目录,修改 sidebar.swig 文件,将下面代码中的 a 标签 加上 rel=”external nofollow”属性 12345&lt;li class="links-of-blogroll-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" title="&#123;&#123; name &#125;&#125;" target="_blank" rel="external nofollow"&gt; &#123;&#123; name &#125;&#125; &lt;/a&gt;&lt;/li&gt; 百度收录生在我大天朝，使用频率最多的当属百度了，下面简单介绍下百度的一些优化处理。 注册账号打开百度站长，注册登录账号 添加网站左侧 我的网站–》站点管理 添加网站，按照引导步骤来就好了。见下图： 在第三步 验证网站这里 建议选择文件验证或者 CNAME 验证，验证规则选项下面已经给出了。PS：将下载下来的文件放至根目录/source 目录下，若为 HTML 格式，需要在文件内加上 layout: false 否则在编译的时候 也会一起编译。 1234---layout: false---J9sxxxxx 继续 hexo d -g 将文件上传至我们的网站，查看刚才的文件是否成功上传，然后点击完成验证。 链接提交在左侧找到链接提交，右边可以看到提交方式有两种：自动提交，手动提交手动提交我们就不谈了，看看自动提交。主要分为 主动推送，自动推送，sitemap 三种方式。 1 主动推送安装推送插件 1npm install hexo-baidu-url-submit --save 在根目录的_config.yml 配置文件中新增字段： 12345baidu_url_submit: count: 100 # 提交最新的一个链接 host: tigerliu.site # 在百度站长平台中注册的域名 token: bwxxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 deploye 属性 新增字段 12deploy: - type: baidu_url_submitter 2 自动推送这里以 next 主题为例,打开主题配置文件_config.yml 将 baidu_push 设置为 true 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true 3 sitemap将上面我们生成的 sitemap 文件地址 提交到百度，如下图： 所有配置完后，可以利用 site:域名 在百度搜索栏测试我们的结果 例如： site:tigerliu.site结果是不是什么也没找到，百度收录需要一段时间，耐心等待吧！！！ 谷歌收录还是 google 收录快，比百度快的不是一点半点，设置完成基本 2 分钟左右即可看到效果。一起来看看！！！ 注册登录google 站长 添加网站跟百度收录类似，验证网站 使用 google 的推荐方法，也就是百度收录的文件验证。 提交站点地图验证完网站后，回到我们的网站列表，点击网站，如下图： 在左侧的抓取–》点击站点地图 ，添加站点地图（把我们刚才生成的 sitemap.xml 地址添加进去），如图： Google 抓取工具点击左侧的 google 抓取工具，输入抓取地址，点击右边的抓取按钮，即可抓取我们的网站。默认不输入 即为抓取首页，状态栏显示完成即为抓取成功，然后将该地址提交至索引。如图： ps: 至此 google 配置已经完成了，等待 2 分钟，回到 google 搜索页，赶紧试一试！！！ 网易云跟帖博文怎么能少评论功能呢，之前的多说目前已经不可用了，在畅言和网易云跟帖之间，我选了后者。使用之前需要有自己的域名，没有见我的上一篇Hexo 进阶高级教程(一)文章，注册一个，也不贵。下面就来谈谈云跟帖： 畅言需要备案，如果你的网站已经备案可以添加 注册登录万年不变的注册登录，网易云跟帖注册 设置站点信息登录后，点击后台管理，填写站点信息，站点名称随便取，站点网址填我们购买的域名，保存。 获取 productKey点击获取代码，在左侧找到 App SDK,右侧的 APP KEY 即为我们需要的 key,点击复制。如图：以 next 主题为例，在 next 主题配置文件_config.yml 中设置 productKey 12# Gentie productKeygentie_productKey: ea08xxxxx 效果预览： 阅读统计功能next 主题集成了 leancloud，在使用的时候设置好 app_key 和 app_id 就可以使用了。 注册登录leancloud 注册 创建应用登录后在右上角选择国内节点，创建应用。如图： 主题配置鼠标悬浮到新创建的应用上，点击右上角的齿轮进入设置界面,点击应用 key 获取 app_key 和 app_id 如图：将刚才获取到的 key,id 填入主题配置文件 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: yourapp_id app_key: yourapp_key 创建 Class在左侧点击存储，创建一个名为Counter的 Class 文件，这里的名称一定为Counter 不能随意取！！！ PS：设置完后，回到我的博客，随便点击一篇博文，刷新几次 就可以在 leancloud–》存储–》Counter 看到我们的浏览记录了，在我们的博文副标题也可以看到浏览记录。 百度、谷歌统计如何查看自己的博客每天被多少人访问呢~ 下面一起来看看在 hexo 中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。 注册登录百度统计注册、谷歌统计注册 百度统计登录后 在左侧找到代码管理–》点击代码获取–》右侧新增网站，如图：拷贝统计代码 ID 谷歌统计登录后，新增一个统计网站，填写网站信息，点击下面的获取跟踪 ID，如图：进入页面后，你会看到跟踪 ID，复制它，如图： 修改配置文件以 next 主题为例，修改主题配置文件，添加 baidu、googleId 1234# Baidu Analytics IDbaidu_analytics: 9758xxxx# Google Analyticsgoogle_analytics: UA-3534xxxx PS：谷歌统计用的比较少，因为有墙，在加载代码的时候，很容易阻塞。故在国内我们使用百度、CNZZ 比较多！！！ 结语看完上面的介绍，有木有感觉配置还是蛮多的，正所谓工欲善其事，必先利其器。当初博主也花了一周多星期才搭建好一个稍微满意点的博客，总之喜欢博客爱折腾，功夫不负有心人，终会弄出一个非常 6 的博客。祝大家在 HEXO 的路上玩的嗨皮！！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo进阶</tag>
        <tag>hexo+七牛</tag>
        <tag>hexo百度收录</tag>
        <tag>hexo百度统计</tag>
        <tag>hexo seo</tag>
        <tag>hexo google统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶高级教程(一)]]></title>
    <url>%2F2017%2F06%2Fhexo-1%2F</url>
    <content type="text"><![CDATA[Hexo+yilia 主题配置紧接上一篇文章Hexo的那些事儿继续探讨Hexo的主题设置、域名绑定以及附加功能设置。 本文地址：http://tigerliu.site/2017/06/hexo-1/ yilia 主题安装 切换到我们的项目，利用 git 下载主题文件 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia hexo 配置 找到 hexo 根目录下的 _config.yml 修改 theme: yilia 获取最新文件 12cd themes/yiliagit pull Hexo 头像设置、ico 图标设置将头像图片、ico 图标放到主题 source/img 下面打开主题目录下面的配置文件_config.yml 修改头像：ctrl+f 搜索 avatar 改成你自己的头像/img/avatar.jpg 修改头像：ctrl+f 搜索 favicon 改成你自己的图标/img/favicon.ico 建议使用 jpg 格式的图片文件，当然其他格式也行 1234favicon: /img/favicon.ico#你的头像urlavatar: /img/avatar.jpg Hexo 打赏设置将二维码图片放到主题 source/img 下面打开主题目录下面的配置文件_config.yml ctrl+f 搜索 reward_wording 修改打赏文字 alipay 设置支付宝图片地址 weixin 设置微信支付图片地址 123456# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/wechatpay.jpg 效果： 阅读更多设置yilia 主题默认展示全部，需要手动在 md 文章中添加 &lt;!– more –&gt;来截断文章设置：效果： 下面是显示文字设置： excerpt_link 文章截断按钮文字 默认为 more 可自定义 show_all_link 文章右下角常驻链接 默认为’展开全文’ 可自定义 mathjax 数学公式 默认为 false 需要用到数学公式请打开 open_in_new 点击文章链接是否在新窗口打开 默认为 false 12345678# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: true Hexo 域名绑定看到大神们的博客是不是觉得很高大上，别鸡冻 跟着博主一步一步 你也可以这么 6！！！下面介绍 Hexo 与 github、coding 的域名绑定 域名注册下面为国内域名注册商，排名不分先后：阿里云、腾讯云、百度云、新网、西数博主是在阿里云万网注册的，.site/.me/.top/.info/.website/.win 等基本都比较便宜，几块钱就可以玩一年，是不是很兴奋，赶紧去注册一个！！！注册流程按照官网来就好了。 解析 DNS购买完后，需要解析 DNS 地址。以阿里云为例，登录万网 在页面的最左侧管理控制台–》域名与网站（万网）–》选择域名 （见下图）点击域名列表里面的解析 点击添加解析，记录类型选择 CNAME，记录值填 github 给的地址，如：tiger6.github.io,解析线路选择海外，如果你有 coding 解析线路就默认就好了（因为 coding 比 github 快很多），主机记录设置两个 www 和@ 然后点击保存就 OK 了。 Hexo CNAME 设置hexo–》source 文件夹下新建一个 CNAME 文件,里面加上你刚刚购买的域名，例如：tigerliu.site PS:新建的 CNAME 一定不要带任何后缀名，否则报错 github 域名绑定打开我们的 github 项目，点击 Settings 按钮找到 GitHub Pages–&gt;Custom domain 填上刚才购买的域名 点击 Save 就可以看到上面的提示信息 Your site is published at http://tigerliu.site/ 代表绑定成功 PS：github 这里只能绑定一个域名 第一次加载万事俱备是该走一波了，分别运行 hexo clean,hexo d -g 发布查看你的博客！！！地址栏输入你购买的域名，然后就是见证奇迹的时候。。。。。。撒花。。。 PS:运行报错或者访问有问题，可在下面留言]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo Blog</tag>
        <tag>hexo themes</tag>
        <tag>hexo 主题</tag>
        <tag>hexo yilia</tag>
        <tag>hexo 域名</tag>
        <tag>hexo dns</tag>
        <tag>hexo进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JSON]]></title>
    <url>%2F2017%2F06%2Fjson%2F</url>
    <content type="text"><![CDATA[什么是JSONJSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。本文地址：http://tigerliu.site/2017/06/json/ JSON与JS对象的区别 JSON.stringify() JSON.parse() JSON.stringify() –&gt;toJSON的使用 1. JSON与JS对象的区别JSON是可以传输的，因为它是文本格式，但是JS对象是没办法传输的，在语法上，JSON也会更加严格，但是JS对象就很松了 对比内容 JSON JS对象 键名 必须加双引号 可允许不加、加单引号、加双引号 属性值 只能是数值（10进制）、字符串（双引号）、布尔值和null,也可以是数组或者符合JSON要求的对象，不能是函数、NaN,Infinity,-Infinity和undefined 爱啥啥 逗号问题 最后一个属性后面不能有逗号 可以 数值 前导0不能用，小数点后必须有数字 没限制 json不是JS的子集123var code = '"\u2028\u2029"'; JSON.parse(code); // works fine eval(code); // fails 这两个字符\u2028和\u2029分别表示行分隔符和段落分隔符，JSON.parse可以正常解析，但是当做js解析时会报错 2. JSON.stringify() 规则：JSON.stringify(value[, replacer [, space]]) 第二个参数可以是函数，也可以是一个数组 如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理 如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中 如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null 第三个参数用于美化输出——不建议用 注意： 键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号 最后一个属性后面有逗号的，会被自动去掉 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 也就是你的什么new String(“bala”)会变成”bala”，new Number(2017)会变成2017 undefined、任意的函数,以及 symbol 值（symbol详见ES6对symbol的介绍） 3. JSON.parse() 规则：JSON.parse(text[, reviver]) 值得注意的是这里有一个可选的第二个参数，这个参数必须是一个函数，这个函数作用在属性已经被解析但是还没返回前，将属性处理后再返回 注意： 如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。 你可以注意到上面例子最后一组输出看上去没有key，其实这个key是一个空字符串，而最后的object是最后解析完成对象，因为到了最上层，已经没有真正的属性了 4. JSON.stringify() –&gt;toJSON的使用如果你在一个JS对象上实现了toJSON方法，那么调用JSON.stringify去序列化这个JS对象时，JSON.stringify会把这个对象的toJSON方法返回的值作为参数去进行序列化]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>json</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2017%2F06%2Flinux%2F</url>
    <content type="text"><![CDATA[什么是Linux 本文地址：http://tigerliu.site/2017/06/linux/ Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 常用命令 链接远程SSH服务 1ssh root@ip 切换目录 1cd /xxx 覆盖上传文件 1rz -y 退出服务器 1exit 编辑 123456vi test.txt 编辑文件c 按键盘上C键从只读状态切换为编辑状态Esc 从编辑状态切换为只读状态：q 是退出（文件没发生更改时）：q! 不保存退出（文件发生改变时）：wq 保存并退出 创建 12mkdir test 创建文件夹touch test.txt 创建文件 系统命令 12ps 查看当前运行的进程kill -9 QQ.exe 终止进程，-9表示强迫进程立即停止 文档说明 1man xxx 文件列表 123456789101112 ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all)ll 列出文件详细信息l(list) ll xx* 列出xx开头的文件cat 查看文件内容cp 拷贝mv 移动或重命名rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除find 在文件系统中搜索某文件 历史命令 12history按住“CTRL + R”就可以搜索已经执行过的命令，它可以在你写命令时自动补全 解压缩命令 123456tar-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 下面的参数是根据需要在压缩或解压档案时可选的 12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 1234567891011# tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 # tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思 解压tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们遇到过的面试问题总结]]></title>
    <url>%2F2017%2F06%2Finterview%2F</url>
    <content type="text"><![CDATA[写这篇文档主要记录我们常见的一些面试问题，并附上一些答案（仅供参考，部分答案来源网络，文末可留言，一起讨论学习） 本文为笔者所遇到过的一些问题，做个记录备忘！！！本文地址：http://tigerliu.site/2017/06/interview/ CSS篇 常见3栏布局方式有几种 CSS3不定宽高水平垂直居中 如何解决1px问题 JavaScript篇 get/post区别 为何要使用json格式 浏览器内核都有那些 setTimeout/setInterval区别 npm中dev-save与save的区别 写一个方法clone; 实现js五种数据类型(string, number, boolean, array, object)的复制 AMD(requirejs)/CMD(seajs)区别 HTML篇 如何禁止微信横屏 html5除了video/audio还有其他媒体标签？ video支持的视频格式有那些 浏览器篇 浏览器内核都有那些 IE下是如何兼容HTML5新属性 localStorage 与cooice 有什么区别 CSS篇1. 常见3栏布局方式有几种 绝对定位 css: 12345html,body&#123;margin:0; height:100%;&#125;#left,#right&#123;position:absolute; top:0; width:200px; height:100%;&#125;#left&#123;left:0; background:#a0b3d6;&#125;#right&#123;right:0; background:#a0b3d6;&#125;#main&#123;margin:0 210px; background:#ffe6b8; height:100%;&#125; html: 123&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;div id="right"&gt;&lt;/div&gt; margin负值 css: 123456html,body&#123;margin:0; height:100%;&#125;#main&#123;width:100%; height:100%; float:left;&#125;#main #body&#123;margin:0 210px; background:#ffe6b8; height:100%;&#125;#left,#right&#123;width:200px; height:100%; float:left; background:#a0b3d6;&#125;#left&#123;margin-left:-100%;&#125;#right&#123;margin-left:-200px;&#125; html: 12345&lt;div id="main"&gt; &lt;div id="body"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="right"&gt;&lt;/div&gt; 自身浮动 css: 12345html,body&#123;margin:0; height:100%;&#125;#main&#123;height:100%; margin:0 210px; background:#ffe6b8;&#125;#left,#right&#123;width:200px; height:100%; background:#a0b3d6;&#125;#left&#123;float:left;&#125;#right&#123;float:right;&#125; html: 123&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="right"&gt;&lt;/div&gt;&lt;div id="main"&gt;&lt;/div&gt; 弹性盒子 css: 1234html,body&#123;margin:0; height:100%;padding:0&#125;body&#123;display:flex;flex-flow:row wrap;&#125;#left,#right&#123;width:200px; height:100%;background:#a0b3d6;flex:1&#125;#main&#123;background:#ffe6b8;width:100%;height:100%;flex:2&#125; html: 123&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;div id="right"&gt;&lt;/div&gt; 圣杯布局 css: 123456html,body&#123;margin:0; height:100%;padding:0&#125;body&#123;padding-left:100px;padding-right:200px&#125;#left,#right&#123;position:relative; top:0; width:200px; height:100%;background:#a0b3d6;float:left;&#125;#left&#123;margin-left:-100%;left:-100px;&#125;#right&#123;margin-left:-200px;right:-200px&#125;#main&#123;background:#ffe6b8;width:100%;height:100%;float:left&#125; html: 123&lt;div id="main"&gt;&lt;/div&gt;&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="right"&gt;&lt;/div&gt; 源自：http://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/https://juejin.im/post/58481bf8ac502e006ce8c361 2. CSS3不定宽高水平垂直居中 Flex 1.justify-content:center;//子元素水平居中 2 align-items:center;//子元素垂直居中 3 display:-webkit-flex; 在父级元素上面加上上面3句话，就可以实现子元素水平垂直居中。 Transformsdiv绝对定位水平垂直居中【Transforms 变形】 这是最简单的方法，不近能实现绝对居中同样的效果，也支持联合可变高度方式使用。内容块定义transform: translate(-50%,-50%) 必须加上top: 50%; left: 50%; 123456789101112.div1&#123; width: 200px; height: 200px; background-color: pink; position: absolute; text-align: center; left:50%; top: 50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125; 3. 如何解决1px问题实现1PX边框的方法有很多，各有优缺点，比如通过背景图片实现、通过transform: scale(0.5)实现。本次实现的是通过VIEWPORT+rem实现的，优点是可以自适应已知的各类手机屏幕,且不存在其它方法存在的变颜色困难、圆角阴影失效问题。缺点嘛，这方法适全新项目，如果老项目想用这种方法，改动量估计会比较大 12345/*transform: scale(0.5)实现代码*/-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5); 源自：http://blog.csdn.net/bbnbf/article/details/51580569 JavaScript篇1. get/post区别 get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。 post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 建议： get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式； 2. 为何要使用json格式 方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是xml、纯字符串的方式，但json有其独到的好处。google有个自己的协议，叫protobuf，有兴趣可了解一下。 方便转换。有很多的json api提供了json字符串转成对象、对象转换成json串的方法。 易于阅读。json代码的良好结构，可以很直观地了解存的是什么内容。 3. 浏览器内核都有那些 Trident内核代表产品Internet Explorer，又称其为IE内核Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的 FF内核WebKit内核代表作品Safari、Chromewebkit 是一个开源项目 safari/chromePresto内核代表作品OperaPresto opera内核 4. setTimeout/setInterval区别 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout() 只执行 code 一次 setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval()方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作clearInterval() 方法的参数。 5. npm中dev-save与save的区别 dev-save:放在package.json的devDependencies里面 开发环境用devDep save:一个放在package.json 的dependencies 生产环境用dependencies 6. 写一个方法clone; 实现js五种数据类型(string, number, boolean, array, object)的复制1234567891011121314151617181920212223242526function clone(Obj)&#123; var buf; if(Obj instanceof Array)&#123; //数组 buf=[]; var i=Obj.length; while(i--)&#123; buf[i]=clone(Obj[i]); &#125; return buf; &#125;else if(Obj instanceof Object)&#123; //对象类型 buf=&#123;&#125;; for(var k in Obj)&#123; buf[k]=clone(Obj[k]); &#125; return buf; &#125;else&#123; //普通变量 return Obj; &#125;&#125;//test console.log(clone(true));console.log(clone(12));console.log(clone('abc'));console.log(clone(null));console.log(clone([1,2,3]));console.log(clone(&#123;name:'zh',age:'18'&#125;)); 7. AMD(requirejs)/CMD(seajs)区别 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. AMD 推崇依赖前置,CMD 推崇依赖就近。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹 HTML篇1.如何禁止微信横屏 通过js或者html5来设置，不让手机页面横屏 使用QQ浏览器私有meta属性12&lt;!-- QQ浏览器私有属性：强制竖屏 --&gt;&lt;meta name="x5-orientation" content="portrait"&gt; 微信应该不是调用的QQ浏览器，所以不知道有没有效，没见过能限制微信竖屏浏览的代码 2. html5除了video/audio还有其他媒体标签？&lt;video&gt; 标记定义一个视频 &lt;audio&gt; 标记定义音频内容 &lt;source&gt; 标记定义媒体资源 &lt;canvas&gt; 标记定义图片 &lt;embed&gt; 标记定义外部的可交互的内容或插件 比如flash 3. video支持的视频格式有那些 一共支持三种格式： Ogg、MPEG4、WebM。但这三种格式对于浏览器的兼容性却各不同。 注释：Internet Explorer 8 以及更早的版本不支持 &lt;video&gt;标签。 1234格式 IE Firefox Opera Chrome SafariOgg No 3.5+ 10.5+ 5.0+ NoMPEG4 9.0+ No No 5.0+ 3.0+WebM No 4.0+ 10.6+ 6.0+ No 浏览器篇1. 浏览器内核都有那些 Trident内核代表产品Internet Explorer，又称其为IE内核 Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的 FF内核 WebKit内核代表作品Safari、Chromewebkit 是一个开源项目 safari/chrome Presto内核代表作品OperaPresto opera内核 2. IE下是如何兼容HTML5新属性 Coding JavaScript 1234567891011121314&lt;!--[if lt IE9]&gt; &lt;script&gt; (function() &#123; if (! /*@cc_on!@*/ 0) return; var e = "abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video".split(', '); var i= e.length; while (i--)&#123; document.createElement(e[i]) &#125; &#125;)() &lt;/script&gt;&lt;![endif]--&gt; 使用Google的html5shiv包（推荐） 123&lt;!--[if lt IE9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125; 但是如果ie6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢?我们可以参照facebook的做法，即引导用户进入带有noscript标识的 “/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。1234567&lt;!--[if lte IE 8]&gt; &lt;noscript&gt; &lt;style&gt;.html5-wrappers&#123;display:none!important;&#125;&lt;/style&gt; &lt;div class="ie-noscript-warning"&gt;您的浏览器禁用了脚本，请&lt;a href=""&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href="/?noscript=1"&gt;继续访问&lt;/a&gt;. &lt;/div&gt;&lt;/noscript&gt;&lt;![endif]--&gt; 这样可以引导用户开启脚本,或者直接跳转到HTML4标签设计的界面。 来自：http://www.cnblogs.com/Capricornus/archive/2013/03/26/2982122.html 3. localStorage 与cooice 有什么区别 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB &nbsp; 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 &nbsp; 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 &nbsp;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>css</tag>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>常见问题</tag>
        <tag>html</tag>
        <tag>F2E</tag>
        <tag>浏览器</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的那些事儿]]></title>
    <url>%2F2017%2F06%2FHexo-github%2F</url>
    <content type="text"><![CDATA[什么是 Hexo hexo 是一款基于 Node.js 的静态博客框架, hexo github 链接 本文地址：http://tigerliu.site/2017/06/Hexo-github/ Hexo 准备工作未安装 node.js、git 的同学请戳这里Node 本地环境搭建 Hexo 环境搭建利用 npm 命令或者 cnpm(淘宝镜像)即可安装 1npm install -g hexo 或者 cnpm install -g hexo 初始化 hexo,在你喜爱的文件夹下新建 hexo 目录（如 D:\hexo），执行以下指令(在 D:\hexo 内点击鼠标右键，选择 Git bash),Hexo 即会自动在目标文件夹建立网站所需要的所有文件 1hexo init 安装依赖包(hexo-server 初始化默认不带 server) 12npm install --save hexo-servernpm install 现在我们已经搭建起本地的 hexo 博客了，执行以下命令(在 D:\hexo)，然后到浏览器输入 localhost:4000 看看 12hexo generatehexo server 好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到 Github github 创建 注册账号https://github.com/ 输入账号、邮箱、密码,然后点击注册按钮. 创建页面仓库 仓库的名字需要和你的账号对应，格式: yourname.github.io输入基本信息，然后点击创建仓库. 命名规则：你的 github 账号.github.io，这里一定要注意，博主就被坑了。 获取仓库地址打开刚才的仓库，可以看到页面上 Clone or download 按钮，点击获取 SSH 链接地址，若为 HTTPS，点击 use SSH 就可以了，复制链接地址。如图： Hexo 基本配置 目录结构 ├── .deploy #需要部署的文件├── node_modules #Hexo 插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json _config.yml 全局配置文件修改拉到文件底部 修改配置，填写刚刚复制的 git SSH 链接地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 配置文件的冒号“:”后面有一个空格 repo: 刚刚 github 创库地址.git 查看 package.json 项目根目录找到 package.json 查看 dependencies 属性内是否包含 hexo-deployer-git 包含直接运行： 1npm install 不包含： 1npm install hexo-deployer-git --save 至此环境配置就 OK 了 hexo 与 github 关联hexo 默认是使用 git 来提交的，故 git 也需要简单的配置。 修改提交的用户名、邮箱Windows 下打开 Git Bash，输入以下命令，回车 12$ git config --global user.name 你的目标用户名；$ git config --global user.email 你的目标邮箱名; SSH Key 配置继续在 Git Bash 中输入命令，创建 SSH Key，按提示输入密码，可以不填密码一路回车 1$ ssh-keygen -t rsa -C "注册邮箱" 获取 key，打开.ssh 下的 id_rsa.pub 文件，里面的内容就是 key 的内容，ctrl+a 全部拷贝 1$ start ~/.ssh/id_rsa.pub 登录 GitHub，打开”SSH Keys”页面，快捷地址：https://github.com/settings/ssh,添加 SSH key 值，如图： 测试 ssh key 是否成功，使用命令“ssh -T git@github.com”，如果出现 You’ve successfullyauthenticated, but GitHub does not provide shellaccess。这就表示已成功连上 githubPS: 关于更多 git 资料请移步拜读 GIT 操作 hexo 部署运行 hexo clean ,hexo d -g 部署到 github 12hexo cleanhexo d -g 以下提示说明部署成功 1[info] Deploy done: git 刷新 github 就可以看到代码已经更新到 github输入http://yourname.github.io (github 仓库–》Settings–》GitHub Pages 下面的链接就是) 就可以查看效果 Hexo 命令使用 常用命令： 12345678hexo help #查看帮助hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，'Ctrl+C'关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 新建文章 1hexo new "标题" 在 _posts 目录下会生成文件标题.md 123456title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写 编辑完后保存，hexo server，浏览器输入 localhost:4000 预览 Hexo 主题https://hexo.io/themes/https://github.com/hexojs/hexo/wiki/Themes]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
        <tag>github</tag>
        <tag>coding</tag>
        <tag>hexo命令</tag>
      </tags>
  </entry>
</search>
